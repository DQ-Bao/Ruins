#include "ruins_base.h"
#include "ruins_containers.h"
#include "ruins_parser.h"
#include "ruins_string.h"

int main(int argc, char* argv[])
{
    if (argc < 2) { panic("Error: can't find path to assets.conf\n"); }
    string content = file_read_to_string(argv[1]);
    if (content.count == 0 || !content.data) { panic("Failed to read file '%s'\n", argv[1]); }

    i32 texture_count   = 0;
    i32 sprite_count    = 0;
    i32 sound_count     = 0;
    i32 animation_count = 0;

    DynamicArray configs = parse_assets_config(content);

    fprintf(stdout, "// DO NOT EDIT THIS FILE\n");
    fprintf(stdout, "// Generated by config_assets.c from %s\n", argv[1]);
    fprintf(stdout, "#pragma once\n\n");
    for (u64 i = 0; i < configs.count; i++)
    {
        AssetConfig config = darray_get(AssetConfig, &configs, i);
        if (string_equals_cstr(config.type, "texture"))
        {
            fprintf(stdout, "#define %s_INDEX %d\n", config.name.data, texture_count);
            texture_count++;
        }
        else if (string_equals_cstr(config.type, "sprite"))
        {
            fprintf(stdout, "#define %s_INDEX %d\n", config.name.data, sprite_count);
            sprite_count++;
        }
        else if (string_equals_cstr(config.type, "sound"))
        {
            fprintf(stdout, "#define %s_INDEX %d\n", config.name.data, sound_count);
            sound_count++;
        }
        else if (string_equals_cstr(config.type, "animation"))
        {
            fprintf(stdout, "#define %s_INDEX %d\n", config.name.data, animation_count);
            animation_count++;
        }

        string_free(&config.name);
        string_free(&config.type);
        string_free(&config.value);
    }
    darray_destroy(&configs);

    return 0;
}
